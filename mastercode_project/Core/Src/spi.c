/**
  ******************************************************************************
  * @file           : spi.c
  * @brief          : Configuration SPI commune pour Master et Slave LoRa
  *                   STM32F407VG + SX1276 - Identique pour les deux dispositifs
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include "spi.h"

/* USER CODE BEGIN 0 */

/* USER CODE END 0 */

SPI_HandleTypeDef hspi2;

/**
  * @brief SPI2 Initialization Function - IDENTIQUE pour Master et Slave
  * @param None
  * @retval None
  * @note Cette configuration est la même pour les deux dispositifs car :
  *       - Les deux STM32 contrôlent leur propre module SX1276
  *       - Les deux utilisent la même interface hardware
  *       - Seul le code applicatif (main.c) diffère entre TX et RX
  */
void MX_SPI2_Init(void)
{
  /* USER CODE BEGIN SPI2_Init 0 */

  /* USER CODE END SPI2_Init 0 */

  /* USER CODE BEGIN SPI2_Init 1 */

  /* USER CODE END SPI2_Init 1 */

  /* SPI2 parameter configuration - COMMUNE AUX DEUX DISPOSITIFS */
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;              // Les deux en Master pour contrôler SX1276
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;    // Communication bidirectionnelle
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;        // Données 8 bits (standard SX1276)
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;      // CPOL = 0 (requis par SX1276)
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;          // CPHA = 0 (requis par SX1276)
  hspi2.Init.NSS = SPI_NSS_SOFT;                  // NSS contrôlé par software
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16; // ~2.6MHz à 42MHz APB1
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;         // MSB first (standard)
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;         // Mode normal (non TI)
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; // CRC non utilisé
  hspi2.Init.CRCPolynomial = 7;                   // Valeur par défaut

  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  /* USER CODE BEGIN SPI2_Init 2 */

  /* USER CODE END SPI2_Init 2 */
}

/**
  * @brief SPI MSP Initialization - IDENTIQUE pour Master et Slave
  * @param spiHandle: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspInit(SPI_HandleTypeDef* spiHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  if(spiHandle->Instance==SPI2)
  {
    /* USER CODE BEGIN SPI2_MspInit 0 */

    /* USER CODE END SPI2_MspInit 0 */

    /* Enable clocks */
    __HAL_RCC_SPI2_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();

    /**SPI2 GPIO Configuration - IDENTIQUE sur les deux cartes
    PC2     ------> SPI2_MISO (Slave to Master data)
    PC3     ------> SPI2_MOSI (Master to Slave data)
    PB10    ------> SPI2_SCK  (Clock generated by STM32)
    PA4     ------> SPI2_NSS  (Chip Select, software controlled)
    */

    /* Configure MISO and MOSI pins */
    GPIO_InitStruct.Pin = GPIO_PIN_2 | GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    /* Configure SCK pin */
    GPIO_InitStruct.Pin = GPIO_PIN_10;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

    /* Configure NSS pin - Software controlled */
    GPIO_InitStruct.Pin = GPIO_PIN_4;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;     // Output pour contrôle par software
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* Set NSS high by default (SX1276 deselected) */
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_SET);

    /* USER CODE BEGIN SPI2_MspInit 1 */

    /* USER CODE END SPI2_MspInit 1 */
  }
}

/**
  * @brief SPI MSP De-Initialization - IDENTIQUE pour Master et Slave
  * @param spiHandle: SPI handle pointer
  * @retval None
  */
void HAL_SPI_MspDeInit(SPI_HandleTypeDef* spiHandle)
{
  if(spiHandle->Instance==SPI2)
  {
    /* USER CODE BEGIN SPI2_MspDeInit 0 */

    /* USER CODE END SPI2_MspDeInit 0 */

    /* Peripheral clock disable */
    __HAL_RCC_SPI2_CLK_DISABLE();

    /* GPIO pins deconfiguration */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_2 | GPIO_PIN_3);  // MISO, MOSI
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10);               // SCK
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_4);                // NSS

    /* USER CODE BEGIN SPI2_MspDeInit 1 */

    /* USER CODE END SPI2_MspDeInit 1 */
  }
}

/* USER CODE BEGIN 1 */

/**
  * @brief Fonction utilitaire pour contrôler NSS
  * @param state: GPIO_PIN_SET (désélectionner) ou GPIO_PIN_RESET (sélectionner)
  * @retval None
  * @note Fonction commune utilisable dans Master et Slave
  */
void SPI_NSS_Control(GPIO_PinState state)
{
    HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, state);
}

/**
  * @brief Test de communication SPI avec SX1276
  * @retval HAL_StatusTypeDef
  * @note Fonction de diagnostic commune
  */
HAL_StatusTypeDef SPI_Test_Communication(void)
{
    uint8_t version_reg = 0x42;  // Registre version SX1276
    uint8_t version_value = 0x00;
    HAL_StatusTypeDef status;

    // Sélectionner le SX1276
    SPI_NSS_Control(GPIO_PIN_RESET);
    HAL_Delay(1);

    // Envoyer commande de lecture du registre version
    status = HAL_SPI_Transmit(&hspi2, &version_reg, 1, HAL_MAX_DELAY);
    if (status == HAL_OK) {
        status = HAL_SPI_Receive(&hspi2, &version_value, 1, HAL_MAX_DELAY);
    }

    // Désélectionner le SX1276
    SPI_NSS_Control(GPIO_PIN_SET);

    // La version du SX1276 doit être 0x12
    if (status == HAL_OK && version_value == 0x12) {
        return HAL_OK;
    }

    return HAL_ERROR;
}

/* USER CODE END 1 */
